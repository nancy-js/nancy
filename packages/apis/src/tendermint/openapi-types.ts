/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/broadcast_tx_sync": {
    /**
     * Returns with the response from CheckTx. Does not wait for DeliverTx result.
     * @description If you want to be sure that the transaction is included in a block, you can
     * subscribe for the result using JSONRPC via a websocket. See
     * https://docs.tendermint.com/v0.34/app-dev/subscribing-to-events-via-websocket.html
     * If you haven't received anything after a couple of blocks, resend it. If the
     * same happens again, send it to some other node. A few reasons why it could
     * happen:
     *
     * 1. malicious node can drop or pretend it had committed your tx
     * 2. malicious proposer (not necessary the one you're communicating with) can
     * drop transactions, which might become valid in the future
     * (https://github.com/tendermint/tendermint/issues/3322)
     *
     *
     * Please refer to
     * https://docs.tendermint.com/v0.34/tendermint-core/using-tendermint.html#formatting
     * for formatting/encoding rules.
     */
    get: operations["broadcast_tx_sync"];
  };
  "/broadcast_tx_async": {
    /**
     * Returns right away, with no response. Does not wait for CheckTx nor DeliverTx results.
     * @description If you want to be sure that the transaction is included in a block, you can
     * subscribe for the result using JSONRPC via a websocket. See
     * https://docs.tendermint.com/v0.34/app-dev/subscribing-to-events-via-websocket.html
     * If you haven't received anything after a couple of blocks, resend it. If the
     * same happens again, send it to some other node. A few reasons why it could
     * happen:
     *
     * 1. malicious node can drop or pretend it had committed your tx
     * 2. malicious proposer (not necessary the one you're communicating with) can
     * drop transactions, which might become valid in the future
     * (https://github.com/tendermint/tendermint/issues/3322)
     * 3. node can be offline
     *
     * Please refer to
     * https://docs.tendermint.com/v0.34/tendermint-core/using-tendermint.html#formatting
     * for formatting/encoding rules.
     */
    get: operations["broadcast_tx_async"];
  };
  "/broadcast_tx_commit": {
    /**
     * Returns with the responses from CheckTx and DeliverTx.
     * @description IMPORTANT: use only for testing and development. In production, use
     * BroadcastTxSync or BroadcastTxAsync. You can subscribe for the transaction
     * result using JSONRPC via a websocket. See
     * https://docs.tendermint.com/v0.34/app-dev/subscribing-to-events-via-websocket.html
     *
     * CONTRACT: only returns error if mempool.CheckTx() errs or if we timeout
     * waiting for tx to commit.
     *
     * If CheckTx or DeliverTx fail, no error will be returned, but the returned result
     * will contain a non-OK ABCI code.
     *
     * Please refer to
     * https://docs.tendermint.com/v0.34/tendermint-core/using-tendermint.html#formatting
     * for formatting/encoding rules.
     */
    get: operations["broadcast_tx_commit"];
  };
  "/check_tx": {
    /**
     * Checks the transaction without executing it.
     * @description The transaction won't be added to the mempool.
     *
     * Please refer to
     * https://docs.tendermint.com/v0.34/tendermint-core/using-tendermint.html#formatting
     * for formatting/encoding rules.
     *
     * Upon success, the `Cache-Control` header will be set with the default
     * maximum age.
     */
    get: operations["check_tx"];
  };
  "/subscribe": {
    /**
     * Subscribe for events via WebSocket.
     * @description To tell which events you want, you need to provide a query. query is a
     * string, which has a form: "condition AND condition ..." (no OR at the
     * moment). condition has a form: "key operation operand". key is a string with
     * a restricted set of possible symbols ( \t\n\r\\()"'=>< are not allowed).
     * operation can be "=", "<", "<=", ">", ">=", "CONTAINS" AND "EXISTS". operand
     * can be a string (escaped with single quotes), number, date or time.
     *
     * Examples:
     *       tm.event = 'NewBlock'               # new blocks
     *       tm.event = 'CompleteProposal'       # node got a complete proposal
     *       tm.event = 'Tx' AND tx.hash = 'XYZ' # single transaction
     *       tm.event = 'Tx' AND tx.height = 5   # all txs of the fifth block
     *       tx.height = 5                       # all txs of the fifth block
     *
     * Tendermint provides a few predefined keys: tm.event, tx.hash and tx.height.
     * Note for transactions, you can define additional keys by providing events with
     * DeliverTx response.
     *
     * import (
     *     abci "github.com/tendermint/tendermint/abci/types"
     *     "github.com/tendermint/tendermint/libs/pubsub/query"
     * )
     *
     * abci.ResponseDeliverTx{
     *   Events: []abci.Event{
     *       {
     *           Type: "rewards.withdraw",
     *           Attributes: abci.EventAttribute{
     *               {Key: []byte("address"), Value: []byte("AddrA"), Index: true},
     *               {Key: []byte("source"), Value: []byte("SrcX"), Index: true},
     *               {Key: []byte("amount"), Value: []byte("..."), Index: true},
     *               {Key: []byte("balance"), Value: []byte("..."), Index: true},
     *           },
     *       },
     *       {
     *           Type: "rewards.withdraw",
     *           Attributes: abci.EventAttribute{
     *               {Key: []byte("address"), Value: []byte("AddrB"), Index: true},
     *               {Key: []byte("source"), Value: []byte("SrcY"), Index: true},
     *               {Key: []byte("amount"), Value: []byte("..."), Index: true},
     *               {Key: []byte("balance"), Value: []byte("..."), Index: true},
     *           },
     *       },
     *       {
     *           Type: "transfer",
     *           Attributes: abci.EventAttribute{
     *               {Key: []byte("sender"), Value: []byte("AddrC"), Index: true},
     *               {Key: []byte("recipient"), Value: []byte("AddrD"), Index: true},
     *               {Key: []byte("amount"), Value: []byte("..."), Index: true},
     *           },
     *       },
     *   },
     * }
     *
     * All events are indexed by a composite key of the form {eventType}.{evenAttrKey}.
     * In the above examples, the following keys would be indexed:
     *    - rewards.withdraw.address
     *    - rewards.withdraw.source
     *    - rewards.withdraw.amount
     *    - rewards.withdraw.balance
     *    - transfer.sender
     *    - transfer.recipient
     *    - transfer.amount
     *
     * Multiple event types with duplicate keys are allowed and are meant to
     * categorize unique and distinct events. In the above example, all events
     * indexed under the key `rewards.withdraw.address` will have the following
     * values stored and queryable:
     *
     *    - AddrA
     *    - AddrB
     *
     * To create a query for txs where address AddrA withdrew rewards:
     * query.MustParse("tm.event = 'Tx' AND rewards.withdraw.address = 'AddrA'")
     *
     * To create a query for txs where address AddrA withdrew rewards from source Y:
     * query.MustParse("tm.event = 'Tx' AND rewards.withdraw.address = 'AddrA' AND rewards.withdraw.source = 'Y'")
     *
     * To create a query for txs where AddrA transferred funds:
     * query.MustParse("tm.event = 'Tx' AND transfer.sender = 'AddrA'")
     *
     * The following queries would return no results:
     * query.MustParse("tm.event = 'Tx' AND transfer.sender = 'AddrZ'")
     * query.MustParse("tm.event = 'Tx' AND rewards.withdraw.address = 'AddrZ'")
     * query.MustParse("tm.event = 'Tx' AND rewards.withdraw.source = 'W'")
     *
     * See list of all possible events here
     * https://godoc.org/github.com/tendermint/tendermint/types#pkg-constants
     *
     * For complete query syntax, check out
     * https://godoc.org/github.com/tendermint/tendermint/libs/pubsub/query.
     *
     * ```go
     * import rpchttp "github.com/tendermint/rpc/client/http"
     * import "github.com/tendermint/tendermint/types"
     *
     * client := rpchttp.New("tcp:0.0.0.0:26657", "/websocket")
     * err := client.Start()
     * if err != nil {
     *   handle error
     * }
     * defer client.Stop()
     * ctx, cancel := context.WithTimeout(context.Background(), 1 * time.Second)
     * defer cancel()
     * query := "tm.event = 'Tx' AND tx.height = 3"
     * txs, err := client.Subscribe(ctx, "test-client", query)
     * if err != nil {
     *   handle error
     * }
     *
     * go func() {
     *  for e := range txs {
     *    fmt.Println("got ", e.Data.(types.EventDataTx))
     *    }
     * }()
     * ```
     *
     * NOTE: if you're not reading events fast enough, Tendermint might
     * terminate the subscription.
     */
    get: operations["subscribe"];
  };
  "/unsubscribe": {
    /**
     * Unsubscribe from event on Websocket
     * @description ```go
     * client := rpchttp.New("tcp:0.0.0.0:26657", "/websocket")
     * err := client.Start()
     * if err != nil {
     *    handle error
     * }
     * defer client.Stop()
     * query := "tm.event = 'Tx' AND tx.height = 3"
     * err = client.Unsubscribe(context.Background(), "test-client", query)
     * if err != nil {
     *    handle error
     * }
     * ```
     */
    get: operations["unsubscribe"];
  };
  "/unsubscribe_all": {
    /**
     * Unsubscribe from all events via WebSocket
     * @description Unsubscribe from all events via WebSocket
     */
    get: operations["unsubscribe_all"];
  };
  "/health": {
    /**
     * Node heartbeat
     * @description Get node health. Returns empty result (200 OK) on success, no response - in case of an error.
     */
    get: operations["health"];
  };
  "/status": {
    /**
     * Node Status
     * @description Get Tendermint status including node info, pubkey, latest block hash, app hash, block height and time.
     */
    get: operations["status"];
  };
  "/net_info": {
    /**
     * Network informations
     * @description Get network info.
     */
    get: operations["net_info"];
  };
  "/dial_seeds": {
    /**
     * Dial Seeds (Unsafe)
     * @description Dial a peer, this route in under unsafe, and has to manually enabled to use
     *
     *   **Example:** curl 'localhost:26657/dial_seeds?seeds=\["f9baeaa15fedf5e1ef7448dd60f46c01f1a9e9c4@1.2.3.4:26656","0491d373a8e0fcf1023aaf18c51d6a1d0d4f31bd@5.6.7.8:26656"\]'
     */
    get: operations["dial_seeds"];
  };
  "/dial_peers": {
    /**
     * Add Peers/Persistent Peers (unsafe)
     * @description Set a persistent peer, this route in under unsafe, and has to manually enabled to use.
     *
     * **Example:** curl 'localhost:26657/dial_peers?peers=\["f9baeaa15fedf5e1ef7448dd60f46c01f1a9e9c4@1.2.3.4:26656","0491d373a8e0fcf1023aaf18c51d6a1d0d4f31bd@5.6.7.8:26656"\]&persistent=false'
     */
    get: operations["dial_peers"];
  };
  "/blockchain": {
    /**
     * Get block headers (max: 20) for minHeight <= height <= maxHeight.
     * @description Get block headers for minHeight <= height <= maxHeight.
     *
     * At most 20 items will be returned.
     *
     * Upon success, the `Cache-Control` header will be set with the default
     * maximum age.
     */
    get: operations["blockchain"];
  };
  "/block": {
    /**
     * Get block at a specified height
     * @description Get Block.
     *
     * If the `height` field is set to a non-default value, upon success, the
     * `Cache-Control` header will be set with the default maximum age.
     */
    get: operations["block"];
  };
  "/block_by_hash": {
    /**
     * Get block by hash
     * @description Get Block By Hash.
     *
     * Upon success, the `Cache-Control` header will be set with the default
     * maximum age.
     */
    get: operations["block_by_hash"];
  };
  "/block_results": {
    /**
     * Get block results at a specified height
     * @description Get block_results. When the `discard_abci_responses` storage flag is
     * enabled, this endpoint will return an error.
     *
     * If the `height` field is set to a non-default value, upon success, the
     * `Cache-Control` header will be set with the default maximum age.
     */
    get: operations["block_results"];
  };
  "/commit": {
    /**
     * Get commit results at a specified height
     * @description Get Commit.
     *
     * If the `height` field is set to a non-default value, upon success, the
     * `Cache-Control` header will be set with the default maximum age.
     */
    get: operations["commit"];
  };
  "/validators": {
    /**
     * Get validator set at a specified height
     * @description Get Validators. Validators are sorted by voting power.
     *
     * If the `height` field is set to a non-default value, upon success, the
     * `Cache-Control` header will be set with the default maximum age.
     */
    get: operations["validators"];
  };
  "/genesis": {
    /**
     * Get Genesis
     * @description Get genesis.
     *
     * Upon success, the `Cache-Control` header will be set with the default
     * maximum age.
     */
    get: operations["genesis"];
  };
  "/dump_consensus_state": {
    /**
     * Get consensus state
     * @description Get consensus state.
     *
     * Not safe to call from inside the ABCI application during a block execution.
     */
    get: operations["dump_consensus_state"];
  };
  "/consensus_state": {
    /**
     * Get consensus state
     * @description Get consensus state.
     *
     * Not safe to call from inside the ABCI application during a block execution.
     */
    get: operations["consensus_state"];
  };
  "/consensus_params": {
    /**
     * Get consensus parameters
     * @description Get consensus parameters.
     *
     * If the `height` field is set to a non-default value, upon success, the
     * `Cache-Control` header will be set with the default maximum age.
     */
    get: operations["consensus_params"];
  };
  "/unconfirmed_txs": {
    /**
     * Get the list of unconfirmed transactions
     * @description Get list of unconfirmed transactions
     */
    get: operations["unconfirmed_txs"];
  };
  "/num_unconfirmed_txs": {
    /**
     * Get data about unconfirmed transactions
     * @description Get data about unconfirmed transactions
     */
    get: operations["num_unconfirmed_txs"];
  };
  "/tx_search": {
    /**
     * Search for transactions
     * @description Search for transactions w/ their results.
     *
     * See /subscribe for the query syntax.
     */
    get: operations["tx_search"];
  };
  "/block_search": {
    /**
     * Search for blocks by BeginBlock and EndBlock events
     * @description Search for blocks by BeginBlock and EndBlock events.
     *
     * See /subscribe for the query syntax.
     */
    get: operations["block_search"];
  };
  "/tx": {
    /**
     * Get transactions by hash
     * @description Get a transaction
     *
     * Upon success, the `Cache-Control` header will be set with the default
     * maximum age.
     */
    get: operations["tx"];
  };
  "/abci_info": {
    /**
     * Get info about the application.
     * @description Get info about the application.
     *
     * Upon success, the `Cache-Control` header will be set with the default
     * maximum age.
     */
    get: operations["abci_info"];
  };
  "/abci_query": {
    /**
     * Query the application for some information.
     * @description Query the application for some information.
     */
    get: operations["abci_query"];
  };
  "/broadcast_evidence": {
    /**
     * Broadcast evidence of the misbehavior.
     * @description Broadcast evidence of the misbehavior.
     */
    get: operations["broadcast_evidence"];
  };
}

export type webhooks = Record<
  string,
  never
>;

export interface components {
  schemas: {
    JSONRPC: {
      /** @example 0 */
      id?: number;
      /** @example 2.0 */
      jsonrpc?: string;
    };
    /** @description Empty Response */
    EmptyResponse: components["schemas"]["JSONRPC"] & {
      result?: {
        [
          key: string
        ]: unknown;
      };
    };
    /** @description Error Response */
    ErrorResponse: components["schemas"]["JSONRPC"] & {
      /** @example Description of failure */
      error?: string;
    };
    ProtocolVersion: {
      /** @example 7 */
      p2p?: string;
      /** @example 10 */
      block?: string;
      /** @example 0 */
      app?: string;
    };
    PubKey: {
      /** @example tendermint/PubKeyEd25519 */
      type?: string;
      /** @example A6DoBUypNtUAyEHWtQ9bFjfNg8Bo9CrnkUGl6k6OHN4= */
      value?: string;
    };
    NodeInfo: {
      protocol_version?: components["schemas"]["ProtocolVersion"];
      /** @example 5576458aef205977e18fd50b274e9b5d9014525a */
      id?: string;
      /** @example tcp:0.0.0.0:26656 */
      listen_addr?: string;
      /** @example cosmoshub-2 */
      network?: string;
      /** @example 0.32.1 */
      version?: string;
      /** @example 4020212223303800 */
      channels?: string;
      /** @example moniker-node */
      moniker?: string;
      other?: {
        /** @example on */
        tx_index?: string;
        /** @example tcp:0.0.0.0:26657 */
        rpc_address?: string;
      };
    };
    SyncInfo: {
      /** @example 790BA84C3545FCCC49A5C629CEE6EA58A6E875C3862175BDC11EE7AF54703501 */
      latest_block_hash?: string;
      /** @example C9AEBB441B787D9F1D846DE51F3826F4FD386108B59B08239653ABF59455C3F8 */
      latest_app_hash?: string;
      /** @example 1262196 */
      latest_block_height?: string;
      /** @example 2019-08-01T11:52:22.818762194Z */
      latest_block_time?: string;
      /** @example 790BA84C3545FCCC49A5C629CEE6EA58A6E875C3862175BDC11EE7AF54703501 */
      earliest_block_hash?: string;
      /** @example C9AEBB441B787D9F1D846DE51F3826F4FD386108B59B08239653ABF59455C3F8 */
      earliest_app_hash?: string;
      /** @example 1262196 */
      earliest_block_height?: string;
      /** @example 2019-08-01T11:52:22.818762194Z */
      earliest_block_time?: string;
      /** @example false */
      catching_up?: boolean;
    };
    ValidatorInfo: {
      /** @example 5D6A51A8E9899C44079C6AF90618BA0369070E6E */
      address?: string;
      pub_key?: components["schemas"]["PubKey"];
      /** @example 0 */
      voting_power?: string;
    };
    /** @description Status Response */
    Status: {
      node_info?: components["schemas"]["NodeInfo"];
      sync_info?: components["schemas"]["SyncInfo"];
      validator_info?: components["schemas"]["ValidatorInfo"];
    };
    /** @description Status Response */
    StatusResponse: components["schemas"]["JSONRPC"] & {
      result?: components["schemas"]["Status"];
    };
    Monitor: {
      /** @example true */
      Active?: boolean;
      /** @example 2019-07-31T14:31:28.66Z */
      Start?: string;
      /** @example 168901060000000 */
      Duration?: string;
      /** @example 168901040000000 */
      Idle?: string;
      /** @example 5 */
      Bytes?: string;
      /** @example 1 */
      Samples?: string;
      /** @example 0 */
      InstRate?: string;
      /** @example 0 */
      CurRate?: string;
      /** @example 0 */
      AvgRate?: string;
      /** @example 0 */
      PeakRate?: string;
      /** @example 0 */
      BytesRem?: string;
      /** @example 0 */
      TimeRem?: string;
      /** @example 0 */
      Progress?: number;
    };
    Channel: {
      /** @example 48 */
      ID?: number;
      /** @example 1 */
      SendQueueCapacity?: string;
      /** @example 0 */
      SendQueueSize?: string;
      /** @example 5 */
      Priority?: string;
      /** @example 0 */
      RecentlySent?: string;
    };
    ConnectionStatus: {
      /** @example 168901057956119 */
      Duration?: string;
      SendMonitor?: components["schemas"]["Monitor"];
      RecvMonitor?: components["schemas"]["Monitor"];
      Channels?: components["schemas"]["Channel"][];
    };
    Peer: {
      node_info?: components["schemas"]["NodeInfo"];
      /** @example true */
      is_outbound?: boolean;
      connection_status?: components["schemas"]["ConnectionStatus"];
      /** @example 95.179.155.35 */
      remote_ip?: string;
    };
    NetInfo: {
      /** @example true */
      listening?: boolean;
      listeners?: string[];
      /** @example 1 */
      n_peers?: string;
      peers?: components["schemas"]["Peer"][];
    };
    /** @description NetInfo Response */
    NetInfoResponse: components["schemas"]["JSONRPC"] & {
      result?: components["schemas"]["NetInfo"];
    };
    BlockMeta: {
      block_id?: components["schemas"]["BlockID"];
      /** @example 1000000 */
      block_size?: number;
      header?: components["schemas"]["BlockHeader"];
      /** @example 54 */
      num_txs?: string;
    };
    Blockchain: {
      /** @example 1276718 */
      last_height: string;
      block_metas: components["schemas"]["BlockMeta"][];
    };
    /** @description Blockchain info */
    BlockchainResponse: components["schemas"]["JSONRPC"] & {
      result?: components["schemas"]["Blockchain"];
    };
    Commit: {
      /** @example 2 */
      type: number;
      /** @example 1262085 */
      height: string;
      /** @example 0 */
      round: number;
      block_id: components["schemas"]["BlockID"];
      /** @example 2019-08-01T11:39:38.867269833Z */
      timestamp: string;
      /** @example 000001E443FD237E4B616E2FA69DF4EE3D49A94F */
      validator_address: string;
      /** @example 0 */
      validator_index: number;
      /** @example DBchvucTzAUEJnGYpNvMdqLhBAHG4Px8BsOBB3J3mAFCLGeuG7uJqy+nVngKzZdPhPi8RhmE/xcw/M9DOJjEDg== */
      signature: string;
    };
    Block: {
      header?: components["schemas"]["BlockHeader"];
      data?: string[];
      evidence?: components["schemas"]["Evidence"][];
      last_commit?: {
        height?: number;
        round?: number;
        block_id?: components["schemas"]["BlockID"];
        signatures?: components["schemas"]["Commit"][];
      };
    };
    Evidence: {
      type?: string;
      height?: number;
      time?: number;
      total_voting_power?: number;
      validator?: components["schemas"]["Validator"];
    };
    BlockComplete: {
      block_id?: components["schemas"]["BlockID"];
      block?: components["schemas"]["Block"];
    };
    /** @description Blockc info */
    BlockResponse: components["schemas"]["JSONRPC"] & {
      result?: components["schemas"]["BlockComplete"];
    };
    BlockResultsResponse: {
      /** @example 2.0 */
      jsonrpc: string;
      /** @example 0 */
      id: number;
      result: {
        /** @example 12 */
        height: string;
        txs_results?:
          | {
              /** @example 0 */
              code?: string;
              /** @example */
              data?: string;
              /** @example not enough gas */
              log?: string;
              /** @example */
              info?: string;
              /** @example 100 */
              gas_wanted?: string;
              /** @example 100 */
              gas_used?: string;
              events?:
                | {
                    /** @example app */
                    type?: string;
                    attributes?: components["schemas"]["Event"][];
                  }[]
                | null;
              /** @example ibc */
              codespace?: string;
            }[]
          | null;
        begin_block_events?:
          | {
              /** @example app */
              type?: string;
              attributes?: components["schemas"]["Event"][];
            }[]
          | null;
        end_block?:
          | {
              /** @example app */
              type?: string;
              attributes?: components["schemas"]["Event"][];
            }[]
          | null;
        validator_updates?:
          | {
              pub_key?: {
                /** @example tendermint/PubKeyEd25519 */
                type: string;
                /** @example 9tK9IT+FPdf2qm+5c2qaxi10sWP+3erWTKgftn2PaQM= */
                value: string;
              };
              /** @example 300 */
              power?: string;
            }[]
          | null;
        consensus_params_updates?: components["schemas"]["ConsensusParams"];
      };
    };
    CommitResponse: {
      /** @example 2.0 */
      jsonrpc: string;
      /** @example 0 */
      id: number;
      result: {
        signed_header: {
          header: components["schemas"]["BlockHeader"];
          commit: {
            /** @example 1311801 */
            height: string;
            /** @example 0 */
            round: number;
            block_id: components["schemas"]["BlockID"];
            signatures: {
              /** @example 2 */
              block_id_flag?: number;
              /** @example 000001E443FD237E4B616E2FA69DF4EE3D49A94F */
              validator_address?: string;
              /** @example 2019-04-22T17:01:58.376629719Z */
              timestamp?: string;
              /** @example 14jaTQXYRt8kbLKEhdHq7AXycrFImiLuZx50uOjs2+Zv+2i7RTG/jnObD07Jo2ubZ8xd7bNBJMqkgtkd0oQHAw== */
              signature?: string;
            }[];
          };
        };
        /** @example true */
        canonical: boolean;
      };
    };
    ValidatorsResponse: {
      /** @example 2.0 */
      jsonrpc: string;
      /** @example 0 */
      id: number;
      result: {
        /** @example 55 */
        block_height: string;
        validators: components["schemas"]["ValidatorPriority"][];
        /** @example 1 */
        count?: string;
        /** @example 25 */
        total?: string;
      };
    };
    GenesisResponse: {
      /** @example 2.0 */
      jsonrpc: string;
      /** @example 0 */
      id: number;
      result: {
        genesis: {
          /** @example 2019-04-22T17:00:00Z */
          genesis_time: string;
          /** @example cosmoshub-2 */
          chain_id: string;
          /** @example 2 */
          initial_height: string;
          consensus_params: components["schemas"]["ConsensusParams"];
          validators: {
            /** @example B00A6323737F321EB0B8D59C6FD497A14B60938A */
            address?: string;
            pub_key?: {
              /** @example tendermint/PubKeyEd25519 */
              type: string;
              /** @example cOQZvh/h9ZioSeUMZB/1Vy1Xo5x2sjrVjlE/qHnYifM= */
              value: string;
            };
            /** @example 9328525 */
            power?: string;
            /** @example Certus One */
            name?: string;
          }[];
          /** @example */
          app_hash: string;
          app_state?: Record<
            string,
            never
          >;
        };
      };
    };
    DumpConsensusResponse: {
      /** @example 2.0 */
      jsonrpc: string;
      /** @example 0 */
      id: number;
      result: {
        round_state: {
          /** @example 1311801 */
          height: string;
          /** @example 0 */
          round: number;
          /** @example 3 */
          step: number;
          /** @example 2019-08-05T11:28:49.064658805Z */
          start_time: string;
          /** @example 2019-08-05T11:28:44.064658805Z */
          commit_time: string;
          validators: {
            validators: components["schemas"]["ValidatorPriority"][];
            proposer: components["schemas"]["ValidatorPriority"];
          };
          /** @example -1 */
          locked_round: number;
          /** @example -1 */
          valid_round: string;
          votes: {
            /** @example 0 */
            round?: string;
            /**
             * @example [
             *   "nil-Vote",
             *   "Vote{19:46A3F8B8393B 1311801/00/1(Prevote) 000000000000 64CE682305CB @ 2019-08-05T11:28:47.374703444Z}"
             * ]
             */
            prevotes?:
              | string[]
              | null;
            /** @example BA{100:___________________x________________________________________________________________________________} 209706/170220253 = 0.00 */
            prevotes_bit_array?: string;
            /**
             * @example [
             *   "nil-Vote"
             * ]
             */
            precommits?:
              | string[]
              | null;
            /** @example BA{100:____________________________________________________________________________________________________} 0/170220253 = 0.00 */
            precommits_bit_array?: string;
          }[];
          /** @example -1 */
          commit_round: number;
          last_commit: {
            /**
             * @example [
             *   "Vote{0:000001E443FD 1311800/00/2(Precommit) 3071ADB27D1A 77EE1B6B6847 @ 2019-08-05T11:28:43.810128139Z}"
             * ]
             */
            votes: string[];
            /** @example BA{100:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx} 170220253/170220253 = 1.00 */
            votes_bit_array: string;
            peer_maj_23s: Record<
              string,
              never
            >;
          } | null;
          last_validators: {
            validators: components["schemas"]["ValidatorPriority"][];
            proposer: components["schemas"]["ValidatorPriority"];
          };
          /** @example false */
          triggered_timeout_precommit: boolean;
        };
        peers: {
          /** @example 357f6a6c1d27414579a8185060aa8adf9815c43c@68.183.41.207:26656 */
          node_address?: string;
          peer_state?: {
            round_state: {
              /** @example 1311801 */
              height: string;
              /** @example 0 */
              round: string;
              /** @example 3 */
              step: number;
              /** @example 2019-08-05T11:28:49.21730864Z */
              start_time: string;
              /** @example false */
              proposal: boolean;
              proposal_block_parts_header: {
                /** @example 0 */
                total: number;
                /** @example */
                hash: string;
              };
              /** @example -1 */
              proposal_pol_round:
                | number
                | null;
              /** @example ____________________________________________________________________________________________________ */
              proposal_pol:
                | string
                | null;
              /** @example ___________________x________________________________________________________________________________ */
              prevotes:
                | string
                | null;
              /** @example ____________________________________________________________________________________________________ */
              precommits:
                | string
                | null;
              /** @example 0 */
              last_commit_round:
                | number
                | null;
              /** @example xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx */
              last_commit:
                | string
                | null;
              /** @example -1 */
              catchup_commit_round:
                | number
                | null;
              /** @example ____________________________________________________________________________________________________ */
              catchup_commit:
                | string
                | null;
            };
            stats: {
              /** @example 1159558 */
              votes: string;
              /** @example 4786 */
              block_parts: string;
            };
          };
        }[];
      };
    };
    ConsensusStateResponse: {
      /** @example 2.0 */
      jsonrpc: string;
      /** @example 0 */
      id: number;
      result: {
        round_state: {
          /** @example 1262197/0/8 */
          "height/round/step": string;
          /** @example 2019-08-01T11:52:38.962730289Z */
          start_time: string;
          /** @example 634ADAF1F402663BEC2ABC340ECE8B4B45AA906FA603272ACC5F5EED3097E009 */
          proposal_block_hash: string;
          /** @example 634ADAF1F402663BEC2ABC340ECE8B4B45AA906FA603272ACC5F5EED3097E009 */
          locked_block_hash: string;
          /** @example 634ADAF1F402663BEC2ABC340ECE8B4B45AA906FA603272ACC5F5EED3097E009 */
          valid_block_hash: string;
          height_vote_set: {
            /** @example 0 */
            round?: number;
            /**
             * @example [
             *   "Vote{0:000001E443FD 1262197/00/1(Prevote) 634ADAF1F402 7BB974E1BA40 @ 2019-08-01T11:52:35.513572509Z}",
             *   "nil-Vote"
             * ]
             */
            prevotes?: string[];
            /** @example BA{100:xxxxxxxxxxxxxxxxx_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx} 169753436/170151262 = 1.00 */
            prevotes_bit_array?: string;
            /**
             * @example [
             *   "Vote{5:18C78D135C9D 1262197/00/2(Precommit) 634ADAF1F402 8B5EFFFEABCD @ 2019-08-01T11:52:36.25600005Z}",
             *   "nil-Vote"
             * ]
             */
            precommits?: string[];
            /** @example BA{100:xxxxxx_xxxxx_xxxx_x_xxx_xx_xx_xx__x_x_x__xxxxxxxxxxxxxx_xxxx_xx_xxxxxx_xxxxxxxx_xxxx_xxx_x_xxxx__xxx} 118726247/170151262 = 0.70 */
            precommits_bit_array?: string;
          }[];
          proposer: {
            /** @example D540AB022088612AC74B287D076DBFBC4A377A2E */
            address?: string;
            /** @example 0 */
            index?: number;
          };
        };
      };
    };
    ConsensusParamsResponse: {
      /** @example 2.0 */
      jsonrpc: string;
      /** @example 0 */
      id: number;
      result: {
        /** @example 1 */
        block_height: string;
        consensus_params: components["schemas"]["ConsensusParams"];
      };
    };
    NumUnconfirmedTransactionsResponse: {
      /** @example 2.0 */
      jsonrpc: string;
      /** @example 0 */
      id: number;
      result: {
        /** @example 31 */
        n_txs: string;
        /** @example 82 */
        total: string;
        /** @example 19974 */
        total_bytes: string;
      };
    };
    UnconfirmedTransactionsResponse: {
      /** @example 2.0 */
      jsonrpc: string;
      /** @example 0 */
      id: number;
      result: {
        /** @example 82 */
        n_txs: string;
        /** @example 82 */
        total: string;
        /** @example 19974 */
        total_bytes: string;
        /**
         * @example [
         *   "gAPwYl3uCjCMTXENChSMnIkb5ZpYHBKIZqecFEV2tuZr7xIUA75/FmYq9WymsOBJ0XSJ8yV8zmQKMIxNcQ0KFIyciRvlmlgcEohmp5wURXa25mvvEhQbrvwbvlNiT+Yjr86G+YQNx7kRVgowjE1xDQoUjJyJG+WaWBwSiGannBRFdrbma+8SFK2m+1oxgILuQLO55n8mWfnbIzyPCjCMTXENChSMnIkb5ZpYHBKIZqecFEV2tuZr7xIUQNGfkmhTNMis4j+dyMDIWXdIPiYKMIxNcQ0KFIyciRvlmlgcEohmp5wURXa25mvvEhS8sL0D0wwgGCItQwVowak5YB38KRIUCg4KBXVhdG9tEgUxMDA1NBDoxRgaagom61rphyECn8x7emhhKdRCB2io7aS/6Cpuq5NbVqbODmqOT3jWw6kSQKUresk+d+Gw0BhjiggTsu8+1voW+VlDCQ1GRYnMaFOHXhyFv7BCLhFWxLxHSAYT8a5XqoMayosZf9mANKdXArA="
         * ]
         */
        txs:
          | (string | null)[]
          | null;
      };
    };
    TxSearchResponse: {
      /** @example 2.0 */
      jsonrpc: string;
      /** @example 0 */
      id: number;
      result: {
        txs: {
          /** @example D70952032620CC4E2737EB8AC379806359D8E0B17B0488F627997A0B043ABDED */
          hash?: string;
          /** @example 1000 */
          height?: string;
          /** @example 0 */
          index?: number;
          tx_result?: {
            /** @example [{"msg_index":"0","success":true,"log":""}] */
            log: string;
            /** @example 200000 */
            gas_wanted: string;
            /** @example 28596 */
            gas_used: string;
            tags: components["schemas"]["Event"];
          };
          /** @example 5wHwYl3uCkaoo2GaChQmSIu8hxpJxLcCuIi8fiHN4TMwrRIU/Af1cEG7Rcs/6LjTl7YjRSymJfYaFAoFdWF0b20SCzE0OTk5OTk1MDAwEhMKDQoFdWF0b20SBDUwMDAQwJoMGmoKJuta6YchAwswBShaB1wkZBctLIhYqBC3JrAI28XGzxP+rVEticGEEkAc+khTkKL9CDE47aDvjEHvUNt+izJfT4KVF2v2JkC+bmlH9K08q3PqHeMI9Z5up+XMusnTqlP985KF+SI5J3ZOIhhNYWRlIGJ5IENpcmNsZSB3aXRoIGxvdmU= */
          tx?: string;
          proof?: {
            /** @example 72FE6BF6D4109105357AECE0A82E99D0F6288854D16D8767C5E72C57F876A14D */
            RootHash: string;
            /** @example 5wHwYl3uCkaoo2GaChQmSIu8hxpJxLcCuIi8fiHN4TMwrRIU/Af1cEG7Rcs/6LjTl7YjRSymJfYaFAoFdWF0b20SCzE0OTk5OTk1MDAwEhMKDQoFdWF0b20SBDUwMDAQwJoMGmoKJuta6YchAwswBShaB1wkZBctLIhYqBC3JrAI28XGzxP+rVEticGEEkAc+khTkKL9CDE47aDvjEHvUNt+izJfT4KVF2v2JkC+bmlH9K08q3PqHeMI9Z5up+XMusnTqlP985KF+SI5J3ZOIhhNYWRlIGJ5IENpcmNsZSB3aXRoIGxvdmU= */
            Data: string;
            Proof: {
              /** @example 2 */
              total: string;
              /** @example 0 */
              index: string;
              /** @example eoJxKCzF3m72Xiwb/Q43vJ37/2Sx8sfNS9JKJohlsYI= */
              leaf_hash: string;
              /**
               * @example [
               *   "eWb+HG/eMmukrQj4vNGyFYb3nKQncAWacq4HF5eFzDY="
               * ]
               */
              aunts: string[];
            };
          };
        }[];
        /** @example 2 */
        total_count: string;
      };
    };
    TxResponse: {
      /** @example 2.0 */
      jsonrpc: string;
      /** @example 0 */
      id: number;
      result: {
        /** @example D70952032620CC4E2737EB8AC379806359D8E0B17B0488F627997A0B043ABDED */
        hash: string;
        /** @example 1000 */
        height: string;
        /** @example 0 */
        index: number;
        tx_result: {
          /** @example [{"msg_index":"0","success":true,"log":""}] */
          log: string;
          /** @example 200000 */
          gas_wanted: string;
          /** @example 28596 */
          gas_used: string;
          tags: components["schemas"]["Event"][];
        };
        /** @example 5wHwYl3uCkaoo2GaChQmSIu8hxpJxLcCuIi8fiHN4TMwrRIU/Af1cEG7Rcs/6LjTl7YjRSymJfYaFAoFdWF0b20SCzE0OTk5OTk1MDAwEhMKDQoFdWF0b20SBDUwMDAQwJoMGmoKJuta6YchAwswBShaB1wkZBctLIhYqBC3JrAI28XGzxP+rVEticGEEkAc+khTkKL9CDE47aDvjEHvUNt+izJfT4KVF2v2JkC+bmlH9K08q3PqHeMI9Z5up+XMusnTqlP985KF+SI5J3ZOIhhNYWRlIGJ5IENpcmNsZSB3aXRoIGxvdmU= */
        tx: string;
      };
    };
    ABCIInfoResponse: {
      /** @example 2.0 */
      jsonrpc: string;
      /** @example 0 */
      id: number;
      result?: {
        response: {
          /** @example {"size":0} */
          data: string;
          /** @example 0.16.1 */
          version: string;
          /** @example 1314126 */
          app_version: string;
        };
      };
    };
    ABCIQueryResponse: {
      /** @example */
      error: string;
      result: {
        response: {
          /** @example exists */
          log: string;
          /** @example 0 */
          height: string;
          /** @example 010114FED0DAD959F36091AD761C922ABA3CBF1D8349990101020103011406AA2262E2F448242DF2C2607C3CDC705313EE3B0001149D16177BC71E445476174622EA559715C293740C */
          proof: string;
          /** @example 61626364 */
          value: string;
          /** @example 61626364 */
          key: string;
          /** @example -1 */
          index: string;
          /** @example 0 */
          code: string;
        };
      };
      /** @example 0 */
      id: number;
      /** @example 2.0 */
      jsonrpc: string;
    };
    BroadcastEvidenceResponse: {
      /** @example */
      error?: string;
      /** @example */
      result?: string;
      /** @example 0 */
      id: number;
      /** @example 2.0 */
      jsonrpc: string;
    };
    BroadcastTxCommitResponse: {
      /** @example */
      error: string;
      result: {
        /** @example 26682 */
        height: string;
        /** @example 75CA0F856A4DA078FC4911580360E70CEFB2EBEE */
        hash: string;
        deliver_tx: {
          /** @example */
          log: string;
          /** @example */
          data: string;
          /** @example 0 */
          code: string;
        };
        check_tx: {
          /** @example */
          log: string;
          /** @example */
          data: string;
          /** @example 0 */
          code: string;
        };
      };
      /** @example 0 */
      id: number;
      /** @example 2.0 */
      jsonrpc: string;
    };
    CheckTxResponse: {
      /** @example */
      error: string;
      result: {
        /** @example 0 */
        code: string;
        /** @example */
        data: string;
        /** @example */
        log: string;
        /** @example */
        info?: string;
        /** @example 1 */
        gas_wanted?: string;
        /** @example 0 */
        gas_used?: string;
        events?:
          | {
              /** @example app */
              type?: string;
              attributes?: components["schemas"]["Event"][];
            }[]
          | null;
        /** @example bank */
        codespace?: string;
      };
      /** @example 0 */
      id: number;
      /** @example 2.0 */
      jsonrpc: string;
    };
    BroadcastTxResponse: {
      /** @example 2.0 */
      jsonrpc: string;
      /** @example 0 */
      id: number;
      result: {
        /** @example 0 */
        code: string;
        /** @example */
        data: string;
        /** @example */
        log: string;
        /** @example ibc */
        codespace?: string;
        /** @example 0D33F2F03A5234F38706E43004489E061AC40A2E */
        hash: string;
      };
      /** @example */
      error: string;
    };
    dialResp: {
      /** @example Dialing seeds in progress. See /net_info for details */
      Log?: string;
    };
    ValidatorPriority: {
      /** @example 000001E443FD237E4B616E2FA69DF4EE3D49A94F */
      address?: string;
      pub_key?: {
        /** @example tendermint/PubKeyEd25519 */
        type: string;
        /** @example 9tK9IT+FPdf2qm+5c2qaxi10sWP+3erWTKgftn2PaQM= */
        value: string;
      };
      /** @example 239727 */
      voting_power?: string;
      /** @example -11896414 */
      proposer_priority?: string;
    };
    Validator: {
      pub_key?: components["schemas"]["PubKey"];
      voting_power?: number;
      address?: string;
    };
    ConsensusParams: {
      block: {
        /** @example 22020096 */
        max_bytes: string;
        /** @example 1000 */
        max_gas: string;
        /** @example 1000 */
        time_iota_ms: string;
      };
      evidence: {
        /** @example 100000 */
        max_age: string;
      };
      validator: {
        /**
         * @example [
         *   "ed25519"
         * ]
         */
        pub_key_types: string[];
      };
    } | null;
    Event: {
      /** @example YWN0aW9u */
      key?: string;
      /** @example c2VuZA== */
      value?: string;
      /** @example false */
      index?: boolean;
    };
    BlockHeader: {
      version: {
        /** @example 10 */
        block: string;
        /** @example 0 */
        app: string;
      };
      /** @example cosmoshub-2 */
      chain_id: string;
      /** @example 12 */
      height: string;
      /** @example 2019-04-22T17:01:51.701356223Z */
      time: string;
      last_block_id: components["schemas"]["BlockID"];
      /** @example 21B9BC845AD2CB2C4193CDD17BFC506F1EBE5A7402E84AD96E64171287A34812 */
      last_commit_hash: string;
      /** @example 970886F99E77ED0D60DA8FCE0447C2676E59F2F77302B0C4AA10E1D02F18EF73 */
      data_hash: string;
      /** @example D658BFD100CA8025CFD3BECFE86194322731D387286FBD26E059115FD5F2BCA0 */
      validators_hash: string;
      /** @example D658BFD100CA8025CFD3BECFE86194322731D387286FBD26E059115FD5F2BCA0 */
      next_validators_hash: string;
      /** @example 0F2908883A105C793B74495EB7D6DF2EEA479ED7FC9349206A65CB0F9987A0B8 */
      consensus_hash: string;
      /** @example 223BF64D4A01074DC523A80E76B9BBC786C791FB0A1893AC5B14866356FCFD6C */
      app_hash: string;
      /** @example */
      last_results_hash: string;
      /** @example */
      evidence_hash: string;
      /** @example D540AB022088612AC74B287D076DBFBC4A377A2E */
      proposer_address: string;
    };
    BlockID: {
      /** @example 112BC173FD838FB68EB43476816CD7B4C6661B6884A9E357B417EE957E1CF8F7 */
      hash: string;
      parts: {
        /** @example 1 */
        total: number;
        /** @example 38D4B26B5B725C4F13571EFE022C030390E4C33C8CF6F88EDD142EA769642DBD */
        hash: string;
      };
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<
  string,
  never
>;

export type external = Record<
  string,
  never
>;

export interface operations {
  /**
   * Returns with the response from CheckTx. Does not wait for DeliverTx result.
   * @description If you want to be sure that the transaction is included in a block, you can
   * subscribe for the result using JSONRPC via a websocket. See
   * https://docs.tendermint.com/v0.34/app-dev/subscribing-to-events-via-websocket.html
   * If you haven't received anything after a couple of blocks, resend it. If the
   * same happens again, send it to some other node. A few reasons why it could
   * happen:
   *
   * 1. malicious node can drop or pretend it had committed your tx
   * 2. malicious proposer (not necessary the one you're communicating with) can
   * drop transactions, which might become valid in the future
   * (https://github.com/tendermint/tendermint/issues/3322)
   *
   *
   * Please refer to
   * https://docs.tendermint.com/v0.34/tendermint-core/using-tendermint.html#formatting
   * for formatting/encoding rules.
   */
  broadcast_tx_sync: {
    parameters: {
      query: {
        /**
         * @description The transaction
         * @example 456
         */
        tx: string;
      };
    };
    responses: {
      /** @description Empty */
      200: {
        content: {
          "application/json": components["schemas"]["BroadcastTxResponse"];
        };
      };
      /** @description Error */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Returns right away, with no response. Does not wait for CheckTx nor DeliverTx results.
   * @description If you want to be sure that the transaction is included in a block, you can
   * subscribe for the result using JSONRPC via a websocket. See
   * https://docs.tendermint.com/v0.34/app-dev/subscribing-to-events-via-websocket.html
   * If you haven't received anything after a couple of blocks, resend it. If the
   * same happens again, send it to some other node. A few reasons why it could
   * happen:
   *
   * 1. malicious node can drop or pretend it had committed your tx
   * 2. malicious proposer (not necessary the one you're communicating with) can
   * drop transactions, which might become valid in the future
   * (https://github.com/tendermint/tendermint/issues/3322)
   * 3. node can be offline
   *
   * Please refer to
   * https://docs.tendermint.com/v0.34/tendermint-core/using-tendermint.html#formatting
   * for formatting/encoding rules.
   */
  broadcast_tx_async: {
    parameters: {
      query: {
        /** @description The transaction */
        tx: string;
      };
    };
    responses: {
      /** @description empty answer */
      200: {
        content: {
          "application/json": components["schemas"]["BroadcastTxResponse"];
        };
      };
      /** @description empty error */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Returns with the responses from CheckTx and DeliverTx.
   * @description IMPORTANT: use only for testing and development. In production, use
   * BroadcastTxSync or BroadcastTxAsync. You can subscribe for the transaction
   * result using JSONRPC via a websocket. See
   * https://docs.tendermint.com/v0.34/app-dev/subscribing-to-events-via-websocket.html
   *
   * CONTRACT: only returns error if mempool.CheckTx() errs or if we timeout
   * waiting for tx to commit.
   *
   * If CheckTx or DeliverTx fail, no error will be returned, but the returned result
   * will contain a non-OK ABCI code.
   *
   * Please refer to
   * https://docs.tendermint.com/v0.34/tendermint-core/using-tendermint.html#formatting
   * for formatting/encoding rules.
   */
  broadcast_tx_commit: {
    parameters: {
      query: {
        /** @description The transaction */
        tx: string;
      };
    };
    responses: {
      /** @description empty answer */
      200: {
        content: {
          "application/json": components["schemas"]["BroadcastTxCommitResponse"];
        };
      };
      /** @description empty error */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Checks the transaction without executing it.
   * @description The transaction won't be added to the mempool.
   *
   * Please refer to
   * https://docs.tendermint.com/v0.34/tendermint-core/using-tendermint.html#formatting
   * for formatting/encoding rules.
   *
   * Upon success, the `Cache-Control` header will be set with the default
   * maximum age.
   */
  check_tx: {
    parameters: {
      query: {
        /** @description The transaction */
        tx: string;
      };
    };
    responses: {
      /** @description ABCI application's CheckTx response */
      200: {
        content: {
          "application/json": components["schemas"]["CheckTxResponse"];
        };
      };
      /** @description empty error */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Subscribe for events via WebSocket.
   * @description To tell which events you want, you need to provide a query. query is a
   * string, which has a form: "condition AND condition ..." (no OR at the
   * moment). condition has a form: "key operation operand". key is a string with
   * a restricted set of possible symbols ( \t\n\r\\()"'=>< are not allowed).
   * operation can be "=", "<", "<=", ">", ">=", "CONTAINS" AND "EXISTS". operand
   * can be a string (escaped with single quotes), number, date or time.
   *
   * Examples:
   *       tm.event = 'NewBlock'               # new blocks
   *       tm.event = 'CompleteProposal'       # node got a complete proposal
   *       tm.event = 'Tx' AND tx.hash = 'XYZ' # single transaction
   *       tm.event = 'Tx' AND tx.height = 5   # all txs of the fifth block
   *       tx.height = 5                       # all txs of the fifth block
   *
   * Tendermint provides a few predefined keys: tm.event, tx.hash and tx.height.
   * Note for transactions, you can define additional keys by providing events with
   * DeliverTx response.
   *
   * import (
   *     abci "github.com/tendermint/tendermint/abci/types"
   *     "github.com/tendermint/tendermint/libs/pubsub/query"
   * )
   *
   * abci.ResponseDeliverTx{
   *   Events: []abci.Event{
   *       {
   *           Type: "rewards.withdraw",
   *           Attributes: abci.EventAttribute{
   *               {Key: []byte("address"), Value: []byte("AddrA"), Index: true},
   *               {Key: []byte("source"), Value: []byte("SrcX"), Index: true},
   *               {Key: []byte("amount"), Value: []byte("..."), Index: true},
   *               {Key: []byte("balance"), Value: []byte("..."), Index: true},
   *           },
   *       },
   *       {
   *           Type: "rewards.withdraw",
   *           Attributes: abci.EventAttribute{
   *               {Key: []byte("address"), Value: []byte("AddrB"), Index: true},
   *               {Key: []byte("source"), Value: []byte("SrcY"), Index: true},
   *               {Key: []byte("amount"), Value: []byte("..."), Index: true},
   *               {Key: []byte("balance"), Value: []byte("..."), Index: true},
   *           },
   *       },
   *       {
   *           Type: "transfer",
   *           Attributes: abci.EventAttribute{
   *               {Key: []byte("sender"), Value: []byte("AddrC"), Index: true},
   *               {Key: []byte("recipient"), Value: []byte("AddrD"), Index: true},
   *               {Key: []byte("amount"), Value: []byte("..."), Index: true},
   *           },
   *       },
   *   },
   * }
   *
   * All events are indexed by a composite key of the form {eventType}.{evenAttrKey}.
   * In the above examples, the following keys would be indexed:
   *    - rewards.withdraw.address
   *    - rewards.withdraw.source
   *    - rewards.withdraw.amount
   *    - rewards.withdraw.balance
   *    - transfer.sender
   *    - transfer.recipient
   *    - transfer.amount
   *
   * Multiple event types with duplicate keys are allowed and are meant to
   * categorize unique and distinct events. In the above example, all events
   * indexed under the key `rewards.withdraw.address` will have the following
   * values stored and queryable:
   *
   *    - AddrA
   *    - AddrB
   *
   * To create a query for txs where address AddrA withdrew rewards:
   * query.MustParse("tm.event = 'Tx' AND rewards.withdraw.address = 'AddrA'")
   *
   * To create a query for txs where address AddrA withdrew rewards from source Y:
   * query.MustParse("tm.event = 'Tx' AND rewards.withdraw.address = 'AddrA' AND rewards.withdraw.source = 'Y'")
   *
   * To create a query for txs where AddrA transferred funds:
   * query.MustParse("tm.event = 'Tx' AND transfer.sender = 'AddrA'")
   *
   * The following queries would return no results:
   * query.MustParse("tm.event = 'Tx' AND transfer.sender = 'AddrZ'")
   * query.MustParse("tm.event = 'Tx' AND rewards.withdraw.address = 'AddrZ'")
   * query.MustParse("tm.event = 'Tx' AND rewards.withdraw.source = 'W'")
   *
   * See list of all possible events here
   * https://godoc.org/github.com/tendermint/tendermint/types#pkg-constants
   *
   * For complete query syntax, check out
   * https://godoc.org/github.com/tendermint/tendermint/libs/pubsub/query.
   *
   * ```go
   * import rpchttp "github.com/tendermint/rpc/client/http"
   * import "github.com/tendermint/tendermint/types"
   *
   * client := rpchttp.New("tcp:0.0.0.0:26657", "/websocket")
   * err := client.Start()
   * if err != nil {
   *   handle error
   * }
   * defer client.Stop()
   * ctx, cancel := context.WithTimeout(context.Background(), 1 * time.Second)
   * defer cancel()
   * query := "tm.event = 'Tx' AND tx.height = 3"
   * txs, err := client.Subscribe(ctx, "test-client", query)
   * if err != nil {
   *   handle error
   * }
   *
   * go func() {
   *  for e := range txs {
   *    fmt.Println("got ", e.Data.(types.EventDataTx))
   *    }
   * }()
   * ```
   *
   * NOTE: if you're not reading events fast enough, Tendermint might
   * terminate the subscription.
   */
  subscribe: {
    parameters: {
      query: {
        /**
         * @description query is a string, which has a form: "condition AND condition ..." (no OR at the
         * moment). condition has a form: "key operation operand". key is a string with
         * a restricted set of possible symbols ( \t\n\r\\()"'=>< are not allowed).
         * operation can be "=", "<", "<=", ">", ">=", "CONTAINS". operand can be a
         * string (escaped with single quotes), number, date or time.
         */
        query: string;
      };
    };
    responses: {
      /** @description empty answer */
      200: {
        content: {
          "application/json": components["schemas"]["EmptyResponse"];
        };
      };
      /** @description empty error */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Unsubscribe from event on Websocket
   * @description ```go
   * client := rpchttp.New("tcp:0.0.0.0:26657", "/websocket")
   * err := client.Start()
   * if err != nil {
   *    handle error
   * }
   * defer client.Stop()
   * query := "tm.event = 'Tx' AND tx.height = 3"
   * err = client.Unsubscribe(context.Background(), "test-client", query)
   * if err != nil {
   *    handle error
   * }
   * ```
   */
  unsubscribe: {
    parameters: {
      query: {
        /**
         * @description query is a string, which has a form: "condition AND condition ..." (no OR at the
         * moment). condition has a form: "key operation operand". key is a string with
         * a restricted set of possible symbols ( \t\n\r\\()"'=>< are not allowed).
         * operation can be "=", "<", "<=", ">", ">=", "CONTAINS". operand can be a
         * string (escaped with single quotes), number, date or time.
         */
        query: string;
      };
    };
    responses: {
      /** @description Answer */
      200: {
        content: {
          "application/json": components["schemas"]["EmptyResponse"];
        };
      };
      /** @description Error */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Unsubscribe from all events via WebSocket
   * @description Unsubscribe from all events via WebSocket
   */
  unsubscribe_all: {
    responses: {
      /** @description empty answer */
      200: {
        content: {
          "application/json": components["schemas"]["EmptyResponse"];
        };
      };
      /** @description empty error */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Node heartbeat
   * @description Get node health. Returns empty result (200 OK) on success, no response - in case of an error.
   */
  health: {
    responses: {
      /** @description Gets Node Health */
      200: {
        content: {
          "application/json": components["schemas"]["EmptyResponse"];
        };
      };
      /** @description empty error */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Node Status
   * @description Get Tendermint status including node info, pubkey, latest block hash, app hash, block height and time.
   */
  status: {
    responses: {
      /** @description Status of the node */
      200: {
        content: {
          "application/json": components["schemas"]["StatusResponse"];
        };
      };
      /** @description empty error */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Network informations
   * @description Get network info.
   */
  net_info: {
    responses: {
      /** @description empty answer */
      200: {
        content: {
          "application/json": components["schemas"]["NetInfoResponse"];
        };
      };
      /** @description empty error */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Dial Seeds (Unsafe)
   * @description Dial a peer, this route in under unsafe, and has to manually enabled to use
   *
   *   **Example:** curl 'localhost:26657/dial_seeds?seeds=\["f9baeaa15fedf5e1ef7448dd60f46c01f1a9e9c4@1.2.3.4:26656","0491d373a8e0fcf1023aaf18c51d6a1d0d4f31bd@5.6.7.8:26656"\]'
   */
  dial_seeds: {
    parameters?: {
      query?: {
        /** @description list of seed nodes to dial */
        peers?: string[];
      };
    };
    responses: {
      /** @description Dialing seeds in progress. See /net_info for details */
      200: {
        content: {
          "application/json": components["schemas"]["dialResp"];
        };
      };
      /** @description empty error */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Add Peers/Persistent Peers (unsafe)
   * @description Set a persistent peer, this route in under unsafe, and has to manually enabled to use.
   *
   * **Example:** curl 'localhost:26657/dial_peers?peers=\["f9baeaa15fedf5e1ef7448dd60f46c01f1a9e9c4@1.2.3.4:26656","0491d373a8e0fcf1023aaf18c51d6a1d0d4f31bd@5.6.7.8:26656"\]&persistent=false'
   */
  dial_peers: {
    parameters?: {
      query?: {
        /** @description Have the peers you are dialing be persistent */
        persistent?: boolean;
        /** @description Have the peers you are dialing be unconditional */
        unconditional?: boolean;
        /** @description Have the peers you are dialing be private */
        private?: boolean;
        /** @description array of peers to dial */
        peers?: string[];
      };
    };
    responses: {
      /** @description Dialing seeds in progress. See /net_info for details */
      200: {
        content: {
          "application/json": components["schemas"]["dialResp"];
        };
      };
      /** @description empty error */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Get block headers (max: 20) for minHeight <= height <= maxHeight.
   * @description Get block headers for minHeight <= height <= maxHeight.
   *
   * At most 20 items will be returned.
   *
   * Upon success, the `Cache-Control` header will be set with the default
   * maximum age.
   */
  blockchain: {
    parameters?: {
      query?: {
        /** @description Minimum block height to return */
        minHeight?: number;
        /** @description Maximum block height to return */
        maxHeight?: number;
      };
    };
    responses: {
      /** @description Block headers, returned in descending order (highest first). */
      200: {
        content: {
          "application/json": components["schemas"]["BlockchainResponse"];
        };
      };
      /** @description Error */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Get block at a specified height
   * @description Get Block.
   *
   * If the `height` field is set to a non-default value, upon success, the
   * `Cache-Control` header will be set with the default maximum age.
   */
  block: {
    parameters?: {
      query?: {
        /** @description height to return. If no height is provided, it will fetch the latest block. */
        height?: number;
      };
    };
    responses: {
      /** @description Block informations. */
      200: {
        content: {
          "application/json": components["schemas"]["BlockResponse"];
        };
      };
      /** @description Error */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Get block by hash
   * @description Get Block By Hash.
   *
   * Upon success, the `Cache-Control` header will be set with the default
   * maximum age.
   */
  block_by_hash: {
    parameters: {
      query: {
        /** @description block hash */
        hash: string;
      };
    };
    responses: {
      /** @description Block informations. */
      200: {
        content: {
          "application/json": components["schemas"]["BlockResponse"];
        };
      };
      /** @description Error */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Get block results at a specified height
   * @description Get block_results. When the `discard_abci_responses` storage flag is
   * enabled, this endpoint will return an error.
   *
   * If the `height` field is set to a non-default value, upon success, the
   * `Cache-Control` header will be set with the default maximum age.
   */
  block_results: {
    parameters?: {
      query?: {
        /** @description height to return. If no height is provided, it will fetch information regarding the latest block. */
        height?: number;
      };
    };
    responses: {
      /** @description Block results. */
      200: {
        content: {
          "application/json": components["schemas"]["BlockResultsResponse"];
        };
      };
      /** @description Error */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Get commit results at a specified height
   * @description Get Commit.
   *
   * If the `height` field is set to a non-default value, upon success, the
   * `Cache-Control` header will be set with the default maximum age.
   */
  commit: {
    parameters?: {
      query?: {
        /** @description height to return. If no height is provided, it will fetch commit informations regarding the latest block. */
        height?: number;
      };
    };
    responses: {
      /**
       * @description Commit results.
       *
       * canonical switches from false to true for block H once block H+1 has been committed. Until then it's subjective and only reflects what this node has seen so far.
       */
      200: {
        content: {
          "application/json": components["schemas"]["CommitResponse"];
        };
      };
      /** @description Error */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Get validator set at a specified height
   * @description Get Validators. Validators are sorted by voting power.
   *
   * If the `height` field is set to a non-default value, upon success, the
   * `Cache-Control` header will be set with the default maximum age.
   */
  validators: {
    parameters?: {
      query?: {
        /** @description height to return. If no height is provided, it will fetch validator set which corresponds to the latest block. */
        height?: number;
        /** @description Page number (1-based) */
        page?: number;
        /** @description Number of entries per page (max: 100) */
        per_page?: number;
      };
    };
    responses: {
      /** @description Commit results. */
      200: {
        content: {
          "application/json": components["schemas"]["ValidatorsResponse"];
        };
      };
      /** @description Error */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Get Genesis
   * @description Get genesis.
   *
   * Upon success, the `Cache-Control` header will be set with the default
   * maximum age.
   */
  genesis: {
    responses: {
      /** @description Genesis results. */
      200: {
        content: {
          "application/json": components["schemas"]["GenesisResponse"];
        };
      };
      /** @description Error */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Get consensus state
   * @description Get consensus state.
   *
   * Not safe to call from inside the ABCI application during a block execution.
   */
  dump_consensus_state: {
    responses: {
      /**
       * @description Complete consensus state.
       *
       * See https://pkg.go.dev/github.com/tendermint/tendermint/types?tab=doc#Vote.String for Vote string description.
       */
      200: {
        content: {
          "application/json": components["schemas"]["DumpConsensusResponse"];
        };
      };
      /** @description Error */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Get consensus state
   * @description Get consensus state.
   *
   * Not safe to call from inside the ABCI application during a block execution.
   */
  consensus_state: {
    responses: {
      /** @description consensus state results. */
      200: {
        content: {
          "application/json": components["schemas"]["ConsensusStateResponse"];
        };
      };
      /** @description Error */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Get consensus parameters
   * @description Get consensus parameters.
   *
   * If the `height` field is set to a non-default value, upon success, the
   * `Cache-Control` header will be set with the default maximum age.
   */
  consensus_params: {
    parameters?: {
      query?: {
        /** @description height to return. If no height is provided, it will fetch commit informations regarding the latest block. */
        height?: number;
      };
    };
    responses: {
      /** @description consensus parameters results. */
      200: {
        content: {
          "application/json": components["schemas"]["ConsensusParamsResponse"];
        };
      };
      /** @description Error */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Get the list of unconfirmed transactions
   * @description Get list of unconfirmed transactions
   */
  unconfirmed_txs: {
    parameters?: {
      query?: {
        /** @description Maximum number of unconfirmed transactions to return (max 100) */
        limit?: number;
      };
    };
    responses: {
      /** @description List of unconfirmed transactions */
      200: {
        content: {
          "application/json": components["schemas"]["UnconfirmedTransactionsResponse"];
        };
      };
      /** @description Error */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Get data about unconfirmed transactions
   * @description Get data about unconfirmed transactions
   */
  num_unconfirmed_txs: {
    responses: {
      /** @description status about unconfirmed transactions */
      200: {
        content: {
          "application/json": components["schemas"]["NumUnconfirmedTransactionsResponse"];
        };
      };
      /** @description Error */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Search for transactions
   * @description Search for transactions w/ their results.
   *
   * See /subscribe for the query syntax.
   */
  tx_search: {
    parameters: {
      query: {
        /** @description Query */
        query: string;
        /** @description Include proofs of the transactions inclusion in the block */
        prove?: boolean;
        /** @description Page number (1-based) */
        page?: number;
        /** @description Number of entries per page (max: 100) */
        per_page?: number;
        /** @description Order in which transactions are sorted ("asc" or "desc"), by height & index. If empty, default sorting will be still applied. */
        order_by?: string;
      };
    };
    responses: {
      /** @description List of unconfirmed transactions */
      200: {
        content: {
          "application/json": components["schemas"]["TxSearchResponse"];
        };
      };
      /** @description Error */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Search for blocks by BeginBlock and EndBlock events
   * @description Search for blocks by BeginBlock and EndBlock events.
   *
   * See /subscribe for the query syntax.
   */
  block_search: {
    parameters: {
      query: {
        /** @description Query */
        query: string;
        /** @description Page number (1-based) */
        page?: number;
        /** @description Number of entries per page (max: 100) */
        per_page?: number;
        /** @description Order in which blocks are sorted ("asc" or "desc"), by height. If empty, default sorting will be still applied. */
        order_by?: string;
      };
    };
    responses: {
      /** @description List of paginated blocks matching the search criteria. */
      200: {
        content: {
          "application/json": unknown; //components["schemas"]["BlockSearchResponse"];
        };
      };
      /** @description Error */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Get transactions by hash
   * @description Get a transaction
   *
   * Upon success, the `Cache-Control` header will be set with the default
   * maximum age.
   */
  tx: {
    parameters: {
      query: {
        /** @description hash of transaction to retrieve */
        hash: string;
        /** @description Include proofs of the transaction's inclusion in the block */
        prove?: boolean;
      };
    };
    responses: {
      /** @description Get a transaction` */
      200: {
        content: {
          "application/json": components["schemas"]["TxResponse"];
        };
      };
      /** @description Error */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Get info about the application.
   * @description Get info about the application.
   *
   * Upon success, the `Cache-Control` header will be set with the default
   * maximum age.
   */
  abci_info: {
    responses: {
      /** @description Get some info about the application. */
      200: {
        content: {
          "application/json": components["schemas"]["ABCIInfoResponse"];
        };
      };
      /** @description Error */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Query the application for some information.
   * @description Query the application for some information.
   */
  abci_query: {
    parameters: {
      query: {
        /** @description Path to the data ("/a/b/c") */
        path: string;
        /** @description Data */
        data: string;
        /** @description Height (0 means latest) */
        height?: number;
        /** @description Include proofs of the transactions inclusion in the block */
        prove?: boolean;
      };
    };
    responses: {
      /** @description Response of the submitted query */
      200: {
        content: {
          "application/json": components["schemas"]["ABCIQueryResponse"];
        };
      };
      /** @description Error */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /**
   * Broadcast evidence of the misbehavior.
   * @description Broadcast evidence of the misbehavior.
   */
  broadcast_evidence: {
    parameters: {
      query: {
        /** @description JSON evidence */
        evidence: string;
      };
    };
    responses: {
      /** @description Broadcast evidence of the misbehavior. */
      200: {
        content: {
          "application/json": components["schemas"]["BroadcastEvidenceResponse"];
        };
      };
      /** @description Error */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
}
